#!/usr/bin/env python


XCLI="xcli"
VERSION=0.7
DEFAULT_REST_IP="127.0.0.1"
DEFAULT_REST_PORT=5757
defaultsocket = DEFAULT_REST_IP+":"+str(DEFAULT_REST_PORT)
GREETING="xDPd v"+str(VERSION)+" command line tool"

try:
	import os
	import cmd
	import sys
	import getopt
	try:
		import urllib2 as urllib
	except:
		import urllib
except Exception as e:
	print "Unable to import dependencies; please install them.\n"+str(e)


#
# Commands and usage
#

def list_show_commands():
	string="\nSubcommands:\n\n"
	string+='   show info\t\t\t\t - Show general info of an xDPd instance\n'
	string+= '   show matching-algorithms\t\t - Show available matching algorithms\n'
	string+= '   show plugins\t\t\t\t - Show compiled-in plugs\n'
	string+= '   show lsis\t\t\t\t - List the existing logical switch instances\n'
	string+= '   show lsi <lsi_name>\t\t\t - Show LSI information\n'
	string+= '   show lsi <lsi_name> table <num> flows - Show LSI table <num> flows\n'
	string+= '   show lsi <lsi_name> group-table\t - List LSI group-table entries\n'
	string+= '   show ports\t\t\t\t - List the existing logical switch instances\n'
	string+= '   show port <port_name>\t\t - Show port information\n'
	return string

def list_exec_commands():
	string="\nSubcommands:\n\n"
	string+='   exec port <port_name> up\t\t\t - Bring port administratively up\n'
	string+='   exec port <port_name> down\t\t\t - Bring port administratively up\n'
	string+='   exec attach port <port_name> <lsi_name>\t - Attach port to a logical switch instance\n'
	string+='   exec detach port <port_name> <lsi_name>\t - Detach port from a logical switch instance\n'
	string+='   exec destroy lsi <lsi_name> \t\t\t - Destroy a logical switch instance\n'
	string+='   exec create vlink <lsi1_name> <lsi2_name>\t - Create a virtual link between two logical switch instances\n'
	return string

def usage():
	print GREETING
	print ''
	print 'Executes a CLI command or launches an interactive CLI session '
	print 'Without arguments, it launches an interactive session'
	print ''
	print 'Return values are always in JSON format'
	print ''
	print 'Usage:'
	print "   "+sys.argv[0]+' [-h] [-c <command>] [-o <output-file>] [-s <host:port>]'
	print ''
	print 'Optional paramenters:'
	print "   -s\t Specify IP and port. default '"+defaultsocket+"'"
	print '   -c\t Execute <command> (e.g. show ports) and exit.'
	print '   -o\t Output to file. Only makes sense when combined with -c'
	print ''
	print 'Available commands:'
	print list_commands()

# Confirm util
def confirm(msg, default=""):
	""" Util confirmation """
	ok = set(['yes','y', 'ye'])
	ko = set(['no','n', '']) #default no
	while 1:
		print "Are you sure %s (Y/N)?" % msg
		aux = raw_input().lower()
		if aux == "" and default != "":
			aux = default
		if aux in ok:
			return True
		elif aux in ko:
			return False

# Unix-style less print
def print_less(msg):
	packing =39 #default line terminal-1 (command)
	lines = msg.split('\n')
	i=0

	if len(lines) <= packing:
		print msg
		return

	while i < len(lines):
		print '\n'.join(lines[i:i+packing])
		if i+packing < len(lines):
			raw_input(": press enter to continue...")
			sys.stdout.write("\033[F") # Cursor up one line
		i += packing

#
# REST
#
def rest(socket, url, payload="", method="GET"):
	complete_url = "http://"+socket+url

	url = ""
	try:
		opener = urllib.build_opener(urllib.HTTPHandler)
		request = urllib.Request(complete_url, payload)
		request.get_method = lambda: method
		url = opener.open(request)
	except urllib.HTTPError as e:
		print "ERROR("+str(e.code)+"): HTTP/"+method+" '"+complete_url+"'"
		if e.code == 401:
			print "Unauthorised; is mgmt support enabled (-m)?"
		elif e.code == 404:
			print e.read()
		else:
			print "Incomplete or malformed request"
		raise
	except Exception as e:
		print "Unkown ERROR:  HTTP/"+method+" '"+complete_url+"'"
		print "  " + str(e)
		raise
	return url.read()


def compose_url(url_array):
	#Compose the url
	url=""
	for section in url_array:
		url +="/"+section
	return url

#
# Command parsing
#
def execute(socket, command, req_confirm=False):

	if command == "":
		print "Invalid command: '"+command+"'"
		return

	#Get operation
	op = command.split()[0]

	if op == "show":
		#Remove trailing spaces
		stripped = command.strip().split()[1:]

		#Check that we really have everything needed
		if len(stripped) == 0:
			print "Invalid command: '"+command+"'. No arguments given to operation '"+op+"'"
			return

		return rest(socket, compose_url(stripped))
	elif op == "exec":
		#Confirm
		if req_confirm:
			res=confirm("", "y")
			sys.stdout.write("\033[F") # Cursor up one line
			if not res:
				return "Canceled";

		#Remove trailing spaces
		stripped = command.strip().split()[1:]

		#Check that we really have everything needed
		if len(stripped) == 0:
			print "Invalid command: '"+command+"'. No arguments given to operation '"+op+"'"
			return

		#Execute the request
		if "create" in command:
			#TODO parse data
			data = ""
			return rest(socket, compose_url(stripped), data, "PUT")
		elif "destroy" in command:
			data = ""
			return rest(socket, compose_url(stripped), data, "DELETE")
		else:
			return rest(socket, compose_url(stripped), "", "POST")
	else:
		print "Unknown op: '"+op+"'"
		return

#
# Cmd based interactive
#
class InteractivePrompt(cmd.Cmd):
	'''
	Interactive CLI
	'''
	def __init__(self, socket):
		cmd.Cmd.__init__(self)
		self.curr = "local"
		self.sockets = {}
		self.sockets[self.curr] = socket
		self.prompt = XCLI + "("+self.curr+")>"
		print GREETING
		print ""
		print "Entering in interactive mode..."
		print "Using target '["+self.curr+"] "+self.sockets[self.curr]+"'"
		print ""
	#
	# Targets
	#
	def do_switch_target(self,s=""):
		if s == "":
			print "Invalid empty target name"
			return
		target = s.split()[0]
		if not target in self.sockets:
			print "Invalid target '"+target+"'"
			return
		self.curr = target

	def complete_switch_target(self, text, line, start_index, end_index):
		return [
			target for target in self.sockets
			if target.startswith(text)
		]

	def help_switch_target(self):
		print "Switch to another xDPd instance (target). Syntax: switch_target <name> <host:port>"

	def do_add_target(self,s=""):
		if s == "":
			print "Invalid empty target name"
			return
		target = s.split()[0]
		socket = s.split()[1]
		if target in self.sockets:
			print "Warning: overwriting '"+target+"' target"
		self.sockets[target] = socket

	def help_add_target(self):
		print "Add an xDPd instance (target) to connect to. Syntax: add_target <name> <host:port>"

	def do_targets(self,s=""):
		for key in self.sockets:
			print "["+key+"] "+self.sockets[key]

	def help_targets(self):
		print "List xDPd instances(targets)"

	#
	# Retrive information
	#
	def do_show(self,s=""):
		if s == "":
			print "Missing arguments"
			return

		result=""
		try:
			result=execute(self.sockets[self.curr], "show "+s)
		except:
			return
		print_less(result)

	def complete_show(self, text, line, start_index, end_index):
		show_cmds = ["system", "plugins", "matching-algorithms", "ports", "port", "lsis", "lsi"]

		for cmd in show_cmds:
			if cmd in line:
				return []

		return [
			cmd for cmd in show_cmds
			if cmd.startswith(text)
		]

	def help_show(self):
		print "Retrieve information information from the target"
		print list_show_commands()

	#
	# Execute remote operations
	#
	def do_exec(self, s=""):
		if s == "":
			print "Missing arguments"
			return
		try:
			result=execute(self.sockets[self.curr], "exec "+s, True)
		except Exception as e:
			print e
			return

		if not result == "":
			print_less(result)

	def complete_exec(self, text, line, start_index, end_index):
		exec_cmds = ["port", "attach", "detach", "create", "destroy"]

		for cmd in exec_cmds:
			if cmd in line:
				return []

		return [
			cmd for cmd in exec_cmds
			if cmd.startswith(text)
		]

	def help_exec(self):
		print "Execute an operation over the target"
		print list_exec_commands()

	#
	# Other
	#
	def do_exit (self,s=""):
		if confirm("that you want to exit"):
			return True

	def help_exit(self):
		print "Exit from the interactive CLI"


	def do_shell(self, s=""):
		if not s=="":
			print os.system(s)

	def help_shell(self):
		print "Execute a command in the OS shell; shell ls -la /"

	def postcmd(self, stop, line):
		self.prompt = XCLI + "("+self.curr+")>"
		print ""
		return stop

	#necessary for \n
	def emptyline(self, s=""):
		"""Do nothing..."""
		pass


##
## Main routine
##
def main(argv):
	command = ''
	outputfile = ''
	socket = defaultsocket

	try:
		opts, args = getopt.getopt(argv,"hs:c:o:",["help", "socket=", "command=","output-file="])
	except getopt.GetoptError:
		usage()
		sys.exit(2)

	for opt, arg in opts:
		if opt in ('-h', "--help"):
			usage()
			sys.exit()
		elif opt in ('-c', "--command"):
			command = arg
		elif opt in ('-s', "--socket"):
			socket = arg
		elif opt in ("-o", "--output-file"):
			outputfile = arg


	if command == "":
		c = InteractivePrompt(socket)
		c.cmdloop()
		sys.exit()
	else:
		try:
			result = execute(socket, command)
		except:
			#We don't care about the exception but we must return
			#the error
			exit(1)

		#Ignore if there was an error
		if result == None or result == "":
			return

		#Output an exit
		if(outputfile):
			f = open(outputfile, "w")
			f.write(result)
		else:
			print result


if __name__ == "__main__":
	main(sys.argv[1:])
