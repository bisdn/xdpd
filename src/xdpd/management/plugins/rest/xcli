#!/usr/bin/env python


XCLI="xcli"
VERSION=0.7
DEFAULT_REST_IP="127.0.0.1"
DEFAULT_REST_PORT=5757
defaultsocket = DEFAULT_REST_IP+":"+str(DEFAULT_REST_PORT)
GREETING="xDPd v"+str(VERSION)+" command line tool"

try:
	import os
	import cmd
	import sys
	import getopt
	import re
	import json
	try:
		import urllib2 as urllib
	except:
		import urllib
except Exception as e:
	print "Unable to import dependencies; please install them.\n"+str(e)


#
# Commands and usage
#

def list_commands():
	string=""
	string+='   show info\t\t\t\t - Show general info of an xDPd instance\n'
	string+= '   show matching-algorithms\t\t - Show available matching algorithms\n'
	string+= '   show plugins\t\t\t\t - Show compiled-in plugs\n'
	string+= '   show lsis\t\t\t\t - List the existing logical switch instances\n'
	string+= '   show lsi <lsi_name>\t\t\t - Show LSI information\n'
	string+= '   show lsi <lsi_name> table <num> flows - Show LSI table <num> flows\n'
	string+= '   show lsi <lsi_name> group-table\t - List LSI group-table entries\n'
	string+= '   show ports\t\t\t\t - List the existing logical switch instances\n'
	string+= '   show port <port_name>\t\t - Show port information\n'
	return string

def usage():
	print GREETING
	print ''
	print 'Executes a CLI command or launches an interactive CLI session '
	print 'Without arguments, it launches an interactive session'
	print ''
	print 'Return values are always in JSON format'
	print ''
	print 'Usage:'
	print "   "+sys.argv[0]+' [-h] [-c <command>] [-o <output-file>] [-s <host:port>]'
	print ''
	print 'Optional paramenters:'
	print "   -s\t Specify IP and port. default '"+defaultsocket+"'"
	print '   -c\t Execute <command> (e.g. show ports) and exit.'
	print '   -o\t Output to file. Only makes sense when combined with -c'
	print ''
	print 'Available commands:'
	print list_commands()

# Confirm util
def confirm(msg):
	""" Util confirmation """
	ok = set(['yes','y', 'ye'])
	ko = set(['no','n', '']) #default no
	while 1:
		print "Are you sure %s (Y/N)?" % msg
		aux = raw_input().lower()
		if aux in ok:
			return True
		elif aux in ko:
			return False

# Unix-style less print
def print_less(msg):
	packing =39 #default line terminal-1 (command)
	lines = msg.split('\n')
	i=0

	if len(lines) <= packing:
		print msg
		return

	while i < len(lines):
		print '\n'.join(lines[i:i+packing])
		if i+packing < len(lines):
			raw_input(": press enter to continue...")
			sys.stdout.write("\033[F") # Cursor up one line
		i += packing

#
# REST
#
def rest_get(socket, url):
	complete_url = "http://"+socket+url

	try:
		json = urllib.urlopen(complete_url).read()
	except urllib.HTTPError as e:
		print "ERROR("+str(e.code)+"): HTTP/GET '"+complete_url+"'"
		if e.code == 404:
			print e.read()
		else:
			print "Incomplete or malformed request"
		raise
	except Exception as e:
		print "Unkown ERROR:  HTTP/GET '"+complete_url+"'"
		print "  " + str(e)
		raise

	return json

def compose_url(url_array):
	#Compose the url
	url=""
	for section in url_array:
		url +="/"+section
	return url

#
# Command parsing
#
def execute(socket, command):

	if command == "":
		print "Invalid command: '"+command+"'"
		return

	#Get operation
	op = command.split()[0]

	if op == "show":
		#Remove trailing spaces
		stripped = command.strip().split()[1:]

		#Check that we really have everything needed
		if len(stripped) == 0:
			print "Invalid command: '"+command+"'. No arguments given to operation '"+op+"'"
			return

		result = rest_get(socket, compose_url(stripped))

		if "flows" in command or "group-table" in command:
			result = sanitize_flow_or_group(result)
		return result

	else:
		print "Unknown op: '"+op+"'"
		return

#
# TODO remove these two functions; this is only needed due to the missing
# feature issue number #13 in ROFL
#
def sanitize_flow_or_group(string):
	#remove \n and \t
	string = re.sub(r'\\n', r'', string)
	string = re.sub(r'\\t', r'', string)

	#remove unuseful blocks in matches
	string = re.sub(r'<cofmatch[^>]*>', r'', string)
	string = re.sub(r'<coxmatches\s*#matches:([^>^\s]*)\s*>', r'(\1)', string)
	string = re.sub(r'<coxmatch[^>]*>', r'', string)
	string = re.sub(r'<cmemory[^>]*>[^<]*<', r'<', string)

	#Annoying comma
	string = re.sub(r'{,\s', r'{', string)

	#Instructions
	string = re.sub(r'<cofintructions[^>]*>', r'', string)
	string = re.sub(r'<cofactions [^>]*>', r'', string)
	string = re.sub(r'<cofaction_([\w]+) ([^>]+)\s*>', r'<\1#\2>', string)
	string = re.sub(r'<cofaction_([\w]+)\s*>', r'<\1#>', string)
	string = re.sub(r'<cofaction [^>]*>', r'', string)
	string = re.sub(r'<cofinstruction_([\w]+)\s*>', r'(\1)', string)
	string = re.sub(r'<cofinstruction_actions[^>]*>', r'', string)
	string = re.sub(r'<cofinstruction[^>]*>', r'', string)

	#Pack
	string = re.sub(r'>\s+<', r', ', string)
	string = re.sub(r'<', r'', string)
	string = re.sub(r'\s*>\s*', r'', string)
	string = re.sub(r' +', r' ', string)
	string = re.sub(r' ,', r',', string)
	string = re.sub(r'\(goto_table\)\s*table-id:\s*(\w+)\s*\(', r'(goto_table:\1) (', string)

	#Spurious stuff
	string = re.sub(r'" id', r'"id', string)
	string = re.sub(r'}}\]\[', r'}[', string)
	string = re.sub(r'\(\s*actions\s*\)', r'', string)
	string = re.sub(r'#, ', r'#', string)

	#Prettify string
	string = json.loads(string)
	string = json.dumps(string, sort_keys=False, indent=4, separators=(',', ': '))
	return string

#
# Cmd based interactive
#
class InteractivePrompt(cmd.Cmd):
	'''
	Interactive CLI
	'''
	def __init__(self, socket):
		cmd.Cmd.__init__(self)
		self.curr = "local"
		self.sockets = {}
		self.sockets[self.curr] = socket
		self.prompt = XCLI + "("+self.curr+")>"
		print GREETING
		print ""
		print "Entering in interactive mode..."
		print "Using target '["+self.curr+"] "+self.sockets[self.curr]+"'"
		print ""

	def postcmd(self, stop, line):
		self.prompt = XCLI + "("+self.curr+")>"
		print ""
		return stop

	def help_exit(self):
		print "Exit from the interactive CLI"

	def do_switch_target(self,s=""):
		if s == "":
			print "Invalid empty target name"
			return
		target = s.split()[0]
		if not target in self.sockets:
			print "Invalid target '"+target+"'"
			return
		self.curr = target

	def complete_switch_target(self, text, line, start_index, end_index):
		return [
			target for target in self.sockets
			if target.startswith(text)
		]

	def help_switch_target(self):
		print "Switch to another xDPd instance (target). Syntax: switch_target <name> <host:port>"

	def do_add_target(self,s=""):
		if s == "":
			print "Invalid empty target name"
			return
		target = s.split()[0]
		socket = s.split()[1]
		if target in self.sockets:
			print "Warning: overwriting '"+target+"' target"
		self.sockets[target] = socket

	def help_add_target(self):
		print "Add an xDPd instance (target) to connect to. Syntax: add_target <name> <host:port>"

	def do_targets(self,s=""):
		for key in self.sockets:
			print "["+key+"] "+self.sockets[key]

	def help_targets(self):
		print "List xDPd instances(targets)"

	#Other useful stuff
	def do_show(self,s=""):
		if s == "":
			print "Missing arguments"
			return

		result=""
		try:
			result=execute(self.sockets[self.curr], "show "+s)
		except:
			return

		print_less(result)

	def complete_show(self, text, line, start_index, end_index):
		show_cmds = ["system", "plugins", "matching-algorithms", "ports", "port", "lsis", "lsi"]

		for cmd in show_cmds:
			if cmd in line:
				return []

		return [
			cmd for cmd in show_cmds
			if cmd.startswith(text)
		]

	def help_show(self):
		print "Retrieve information information from the xDPd instance"
		print list_commands()

	def do_exit (self,s=""):
		if confirm("that you want to exit"):
			return True

	def do_shell(self, s=""):
		if not s=="":
			print os.system(s)

	def help_shell(self):
		print "Execute a command in the OS shell; shell ls -la /"

	#necessary for \n
	def emptyline(self, s=""):
		"""Do nothing..."""
		pass


##
## Main routine
##
def main(argv):
	command = ''
	outputfile = ''
	socket = defaultsocket

	try:
		opts, args = getopt.getopt(argv,"hs:c:o:",["help", "socket=", "command=","output-file="])
	except getopt.GetoptError:
		usage()
		sys.exit(2)

	for opt, arg in opts:
		if opt in ('-h', "--help"):
			usage()
			sys.exit()
		elif opt in ('-c', "--command"):
			command = arg
		elif opt in ('-s', "--socket"):
			socket = arg
		elif opt in ("-o", "--output-file"):
			outputfile = arg


	if command == "":
		c = InteractivePrompt(socket)
		c.cmdloop()
		sys.exit()
	else:
		try:
			result = execute(socket, command)
		except:
			#We don't care about the exception but we must return
			#the error
			exit(1)

		#Ignore if there was an error
		if result == None or result == "":
			return

		#Output an exit
		if(outputfile):
			f = open(outputfile, "w")
			f.write(result)
		else:
			print result


if __name__ == "__main__":
	main(sys.argv[1:])
